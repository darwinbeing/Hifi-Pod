/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of XMMSClientResult.xs. Do not edit this file, edit XMMSClientResult.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "../src/clients/lib/perl/XMMSClientResult.xs"
#include "perl_xmmsclient.h"

STATIC SV *value_to_sv (xmmsv_t *val);

STATIC int
notifyer_cb (xmmsv_t *val, void *user_data)
{
	int ret;
	PerlXMMSClientCallback *cb = (PerlXMMSClientCallback *)user_data;

	perl_xmmsclient_callback_invoke (cb, &ret, value_to_sv (val));

	return ret;
}

STATIC SV *
sv_from_value_int (xmmsv_t *val)
{
	int ret, num;

	ret = xmmsv_get_int (val, &num);

	if (ret == 0) {
		croak("could not fetch int value");
	}

	return newSViv (num);
}

STATIC SV *
sv_from_value_string (xmmsv_t *val)
{
	int ret;
	const char *str = NULL;

	ret = xmmsv_get_string (val, &str);

	if (ret == 0) {
		croak("could not fetch string value");
	}

	return newSVpv (str, 0);
}

STATIC SV *
sv_from_value_coll (xmmsv_t *val)
{
	int ret;
	xmmsv_coll_t *coll = NULL;

	ret = xmmsv_get_coll (val, &coll);

	if (ret == 0) {
		croak("could not fetch collection value");
	}

	return perl_xmmsclient_new_sv_from_ptr ((void *)coll, "Audio::XMMSClient::Collection");
}

STATIC SV *
sv_from_value_bin (xmmsv_t *val)
{
	int ret;
	const unsigned char *bin;
	unsigned int bin_len = 0;

	ret = xmmsv_get_bin (val, &bin, &bin_len);

	if (ret == 0) {
		croak("could not fetch bin value");
	}

	return newSVpv ((char *)bin, bin_len);
}

STATIC void
list_foreach_cb (xmmsv_t *value, void *user_data)
{
	AV *list = (AV *)user_data;
	av_push (list, value_to_sv (value));
}

STATIC SV *
sv_from_value_list (xmmsv_t *val)
{
	int ret;
	AV *list = newAV ();

	ret = xmmsv_list_foreach (val, list_foreach_cb, list);

	if (ret == 0) {
		croak ("could not fetch list value");
	}

	return newRV_inc ((SV *)list);
}

STATIC void
dict_foreach_cb (const char *key, xmmsv_t *value, void *user_data)
{
	HV *hash = (HV *)user_data;

	if (!hv_store (hash, key, strlen (key), value_to_sv (value), 0)) {
		croak ("failed to convert result to hash");
	}
}

STATIC SV *
sv_from_value_dict (xmmsv_t *val)
{
	int ret;
	HV *dict = newHV ();

	ret = xmmsv_dict_foreach (val, dict_foreach_cb, dict);

	if (ret == 0) {
		croak ("could not fetch dict value");
	}

	return newRV_inc ((SV *)dict);
}

STATIC void
croak_value_error (xmmsv_t *val) {
	int ret;
	const char *msg;

	ret = xmmsv_get_error (val, &msg);

	if (ret == 0) {
		croak ("could not fetch error message");
	}

	croak ("%s", msg);
}

STATIC SV *
value_to_sv (xmmsv_t *value) {
	xmmsv_type_t type;
	SV *ret;

	type = xmmsv_get_type (value);

	switch (type) {
		case XMMSV_TYPE_NONE:
			ret = &PL_sv_undef;
			break;
		case XMMSV_TYPE_ERROR:
			croak_value_error (value);
			break;
		case XMMSV_TYPE_INT32:
			ret = sv_from_value_int (value);
			break;
		case XMMSV_TYPE_STRING:
			ret = sv_from_value_string (value);
			break;
		case XMMSV_TYPE_COLL:
			ret = sv_from_value_coll (value);
			break;
		case XMMSV_TYPE_BIN:
			ret = sv_from_value_bin (value);
			break;
		case XMMSV_TYPE_LIST:
			ret = sv_from_value_list (value);
			break;
		case XMMSV_TYPE_DICT:
			ret = sv_from_value_dict (value);
			break;
		default:
			croak ("unhandled value type");
	}

	return ret;
}

#line 186 "../src/clients/lib/perl/XMMSClientResult.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 229 "../src/clients/lib/perl/XMMSClientResult.c"

XS(XS_Audio__XMMSClient__Result_get_class); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_get_class)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "res");
    {
	xmmsc_result_t *	res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (ST(0), "Audio::XMMSClient::Result");
	xmmsc_result_type_t	RETVAL;

	RETVAL = xmmsc_result_get_class(res);
	ST(0) = sv_newmortal();
	{
		ST(0) = newSVpv ("unknown", 0);
		if (RETVAL == XMMSC_RESULT_CLASS_DEFAULT) {
			sv_setpv (ST(0), "default");
		} else if (RETVAL == XMMSC_RESULT_CLASS_SIGNAL) {
			sv_setpv (ST(0), "signal");
		} else if (RETVAL == XMMSC_RESULT_CLASS_BROADCAST) {
			sv_setpv (ST(0), "broadcast");
		}
	}

    }
    XSRETURN(1);
}


XS(XS_Audio__XMMSClient__Result_notifier_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_notifier_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "res, func, data=NULL");
    {
	xmmsc_result_t *	res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (ST(0), "Audio::XMMSClient::Result");
	SV *	func = ST(1);
	SV *	data;
#line 244 "../src/clients/lib/perl/XMMSClientResult.xs"
		PerlXMMSClientCallback *cb = NULL;
		PerlXMMSClientCallbackParamType param_types[1];
#line 280 "../src/clients/lib/perl/XMMSClientResult.c"

	if (items < 3)
	    data = NULL;
	else {
	    data = ST(2);
	}
#line 247 "../src/clients/lib/perl/XMMSClientResult.xs"
		param_types[0] = PERL_XMMSCLIENT_CALLBACK_PARAM_TYPE_VALUE;

		cb = perl_xmmsclient_callback_new (func, data, ST(0), 1, param_types,
		                                   PERL_XMMSCLIENT_CALLBACK_RETURN_TYPE_INT);

		xmmsc_result_notifier_set_full (res, notifyer_cb, cb,
		                                (xmmsc_user_data_free_func_t)perl_xmmsclient_callback_destroy);
#line 295 "../src/clients/lib/perl/XMMSClientResult.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Audio__XMMSClient__Result_wait); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_wait)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "res");
    {
	SV *	res = ST(0);
#line 277 "../src/clients/lib/perl/XMMSClientResult.xs"
		xmmsc_result_t *c_res;
#line 315 "../src/clients/lib/perl/XMMSClientResult.c"
	SV *	RETVAL;
#line 279 "../src/clients/lib/perl/XMMSClientResult.xs"
		c_res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (res, "Audio::XMMSClient::Result");

		xmmsc_result_wait (c_res);

		SvREFCNT_inc (res);
		RETVAL = res;
#line 324 "../src/clients/lib/perl/XMMSClientResult.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Audio__XMMSClient__Result_get_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_get_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "res");
    {
	xmmsc_result_t *	res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (ST(0), "Audio::XMMSClient::Result");
	xmmsv_type_t	RETVAL;
#line 309 "../src/clients/lib/perl/XMMSClientResult.xs"
		RETVAL = xmmsv_get_type (xmmsc_result_get_value (res));
#line 347 "../src/clients/lib/perl/XMMSClientResult.c"
	ST(0) = sv_newmortal();
	{
		ST(0) = newSVpv ("unknown", 0);
		if (RETVAL == XMMSV_TYPE_NONE) {
			sv_setpv (ST(0), "none");
		} else if (RETVAL == XMMSV_TYPE_ERROR) {
			sv_setpv (ST(0), "error");
		} else if (RETVAL == XMMSV_TYPE_INT32) {
			sv_setpv (ST(0), "int");
		} else if (RETVAL == XMMSV_TYPE_STRING) {
			sv_setpv (ST(0), "string");
		} else if (RETVAL == XMMSV_TYPE_DICT) {
			sv_setpv (ST(0), "dict");
		} else if (RETVAL == XMMSV_TYPE_BIN) {
			sv_setpv (ST(0), "bin");
		} else if (RETVAL == XMMSV_TYPE_COLL) {
			sv_setpv (ST(0), "coll");
		} else if (RETVAL == XMMSV_TYPE_LIST) {
			sv_setpv (ST(0), "list");
		}
	}

    }
    XSRETURN(1);
}


XS(XS_Audio__XMMSClient__Result_iserror); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_iserror)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "res");
    {
	xmmsc_result_t *	res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (ST(0), "Audio::XMMSClient::Result");
	int	RETVAL;
	dXSTARG;

	RETVAL = xmmsc_result_iserror(res);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Audio__XMMSClient__Result_get_error); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_get_error)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "res");
    {
	xmmsc_result_t *	res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (ST(0), "Audio::XMMSClient::Result");
#line 354 "../src/clients/lib/perl/XMMSClientResult.xs"
		xmmsv_t *val;
#line 411 "../src/clients/lib/perl/XMMSClientResult.c"
	const char *	RETVAL;
	dXSTARG;
#line 356 "../src/clients/lib/perl/XMMSClientResult.xs"
		RETVAL = NULL;
		val = xmmsc_result_get_value (res);
		if (val) {
			xmmsv_get_error (val, &RETVAL);
		}
#line 420 "../src/clients/lib/perl/XMMSClientResult.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Audio__XMMSClient__Result_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "res");
    {
	xmmsc_result_t *	res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (ST(0), "Audio::XMMSClient::Result");
	SV *	RETVAL;
#line 385 "../src/clients/lib/perl/XMMSClientResult.xs"
		RETVAL = value_to_sv (xmmsc_result_get_value (res));
#line 442 "../src/clients/lib/perl/XMMSClientResult.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Audio__XMMSClient__Result_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Audio__XMMSClient__Result_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "res");
    {
	xmmsc_result_t *	res = (xmmsc_result_t *)perl_xmmsclient_get_ptr_from_sv (ST(0), "Audio::XMMSClient::Result");
#line 457 "../src/clients/lib/perl/XMMSClientResult.xs"
		xmmsc_result_unref (res);
#line 464 "../src/clients/lib/perl/XMMSClientResult.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Audio__XMMSClient__Result); /* prototype to pass -Wmissing-prototypes */
XS(boot_Audio__XMMSClient__Result)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("Audio::XMMSClient::Result::get_class", XS_Audio__XMMSClient__Result_get_class, file);
        newXS("Audio::XMMSClient::Result::notifier_set", XS_Audio__XMMSClient__Result_notifier_set, file);
        newXS("Audio::XMMSClient::Result::wait", XS_Audio__XMMSClient__Result_wait, file);
        newXS("Audio::XMMSClient::Result::get_type", XS_Audio__XMMSClient__Result_get_type, file);
        newXS("Audio::XMMSClient::Result::iserror", XS_Audio__XMMSClient__Result_iserror, file);
        newXS("Audio::XMMSClient::Result::get_error", XS_Audio__XMMSClient__Result_get_error, file);
        newXS("Audio::XMMSClient::Result::value", XS_Audio__XMMSClient__Result_value, file);
        newXS("Audio::XMMSClient::Result::DESTROY", XS_Audio__XMMSClient__Result_DESTROY, file);
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

